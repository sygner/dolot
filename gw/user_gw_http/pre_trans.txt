func (c *gameService) TransactionForWinner(data []models.DivisionResult, gameId string) {
	wlt, err := c.walletClient.GetWalletsByUserId(context.Background(), &wallet_pb.UserId{
		UserId: 0,
	})
	if err != nil {
		// return nil, types.ExtractGRPCErrDetails(err)
		return
	}
	if len(wlt.Wallets) <= 0 {
		// return nil, types.NewBadRequestError("Wallet Not found")
		return
	}

	userPrizeMap := make(map[int32]float64) // Store total prize per user
	userIds := make([]int32, 0)

	// Fetch game details
	gameRes, err := c.gameClient.GetGameByGameId(context.Background(), &pb.GameId{GameId: gameId})
	if err != nil || gameRes.Prize == nil {
		fmt.Println("Error fetching game data or prize is nil")
		return
	}

	gameData, rerr := toGameProto(gameRes)
	if rerr != nil {
		return
	}
	jackpot := float64(*gameData.Prize)

	// Calculate total winnings per user
	for _, dr := range data {

		// Select the correct division map based on Game ID
		var divisionMap map[string]float64

		switch gameData.GameType { // Assuming dr.GameID exists
		case "LOTTO":
			divisionMap = LottoWinnerDivisions
		case "OZLOTTO":
			divisionMap = OsLottoWinnerDivisions
		case "POWERBALL":
			divisionMap = PowerballWinnerDivisions
		case "AMERICAN_POWERBALL":
			divisionMap = PowerballWinnerDivisions
		default:
			continue // Skip if game type is unknown
		}

		divisionPercentage, exists := divisionMap[dr.Division]
		if !exists || len(dr.UserChoices) == 0 {
			continue
		}

		var prizePerWinner float64
		if dr.Division == "Division 1" {
			prizePerWinner = jackpot
		} else {
			prizePerWinner = jackpot * divisionPercentage
		}

		for _, uc := range dr.UserChoices {
			if _, exists := userPrizeMap[uc.UserId]; !exists {
				userIds = append(userIds, uc.UserId)
			}
			userPrizeMap[uc.UserId] += prizePerWinner // Sum up winnings
		}
	}

	fmt.Println("User Prize Map:", userPrizeMap)

	// Get user wallets
	res, err := c.walletClient.GetWalletsByUserIdsAndCoinId(context.Background(), &wallet_pb.GetWalletsByUserIdsAndCoinIdRequest{
		UserIds: userIds,
		CoinId:  1,
	})
	if err != nil {
		fmt.Println("Error fetching wallets:", err)
		return
	}

	walletMap := make(map[int32]*wallet_pb.Wallet)
	for _, wallet := range res.Wallets {
		walletMap[wallet.UserId] = wallet
	}

	// Concurrency control
	// var wg sync.WaitGroup
	// sem := make(chan struct{}, 5) // Limit concurrent transactions to 5

	// Process a single transaction per user concurrently
	// wg.Add(len(userPrizeMap))
	for userId, totalPrize := range userPrizeMap {
		wallet, found := walletMap[userId]
		if !found {
			fmt.Printf("No wallet found for user %d\n", userId)
			continue
		}

		// sem <- struct{}{} // Acquire slot

		// go func(userId int32, walletAddress string, amount float64) {
		// 	defer wg.Done()
		// 	defer func() { <-sem }() // Release slot

		// Delay to prevent API flood (optional)
		// time.Sleep(200 * time.Millisecond)
		fmt.Println("Paying Winner Prize...$")
		trx, err := c.walletClient.AddTransaction(context.Background(), &wallet_pb.AddTransactionRequest{
			FromWalletUserId: 0,
			FromWalletId:     wlt.GetWallets()[0].Id,
			ToWalletAddress:  wallet.Address,
			Amount:           math.Round(totalPrize), // Round amount
			CoinId:           1,
		})
		if err != nil {
			fmt.Printf("Transaction failed for user %d: %v\n", userId, err)
		} else {
			fmt.Println(trx)
			fmt.Printf("User %d received %.2f\n", userId, totalPrize)
		}
		// }(userId, wallet.Address, totalPrize)
	}

	// Wait for all transactions to complete
	// wg.Wait()
	fmt.Println("Transaction processing complete.")
}

// Division 1: Jackpot
// Division 2: 11.3% of Jackpot
// Division 3: 17.1% of Jackpot
// Division 4: 25.34% of Jackpot
// Division 5: 37.4% of Jackpot
var LottoWinnerDivisions = map[string]float64{
	"Division 1": 1.0,    // 100% of Jackpot
	"Division 2": 0.374,  // 37.4% of Jackpot
	"Division 3": 0.2534, // 25.34% of Jackpot
	"Division 4": 0.171,  // 17.1% of Jackpot
	"Division 5": 0.113,  // 11.3% of Jackpot
}

// Division 2: 5.5% of the jackpot
// Division 3: 6.5% of the jackpot
// Division 4: 5.0% of the jackpot
// Division 5: 4.0% of the jackpot
// Division 6: 49.5% of the jackpot
var OsLottoWinnerDivisions = map[string]float64{
	"Division 1": 1.0,   // 100% of Jackpot
	"Division 2": 0.055, // 5.5% of Jackpot
	"Division 3": 0.065, // 6.5% of Jackpot
	"Division 4": 0.05,  // 5.0% of Jackpot
	"Division 5": 0.04,  // 4.0% of Jackpot
	"Division 6": 0.495, // 49.5% of Jackpot
}

// Division 1: Jackpot
// Division 2: 5.52% of the jackpot
// Division 3: 6.87% of the jackpot
// Division 4: 5.97% of the jackpot
// Division 5: 4.48% of the jackpot
// Division 6: 28.06% of the jackpot
var PowerballWinnerDivisions = map[string]float64{
	"Division 1": 1.0,    // 100% of Jackpot
	"Division 2": 0.0552, // 5.52% of Jackpot
	"Division 3": 0.0687, // 6.87% of Jackpot
	"Division 4": 0.0597, // 5.97% of Jackpot
	"Division 5": 0.0448, // 4.48% of Jackpot
	"Division 6": 0.2806, // 28.06% of Jackpot
}

// write the contains function
func contains(userIds []int32, userChoices int32) bool {
	for _, id := range userIds {
		if id == userChoices {
			return true
		}
	}
	return false
}






